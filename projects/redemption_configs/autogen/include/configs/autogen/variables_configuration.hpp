//
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
//

namespace cfg {
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct globals::capture_chunk {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "capture_chunk";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(0);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct globals::auth_user {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "auth_user";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(1);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct globals::host {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "host";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(2);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct globals::target {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(3);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct globals::target_device {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target_device";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(4);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct globals::device_id {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "device_id";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(5);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct globals::primary_user_id {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "primary_user_id";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(6);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct globals::target_user {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target_user";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(7);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct globals::target_application {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target_application";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(8);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct globals::target_application_account {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target_application_account";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(9);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct globals::target_application_password {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target_application_password";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(10);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Support of Bitmap Cache. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::bitmap_cache {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "bitmap_cache";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::glyph_cache {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "glyph_cache";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: unsigned int <br/>
    /// value{3389} <br/>
    struct globals::port {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "port";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{3389};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::nomouse {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "nomouse";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::notimestamp {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "notimestamp";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: Level <br/>
    /// value = static_cast<type>(0) <br/>
    struct globals::encryptionLevel {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "encryptionLevel";
        using type = Level;
        using sesman_and_spec_type = Level;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// type: std::string <br/>
    /// value = REDEMPTION_CONFIG_AUTHFILE <br/>
    struct globals::authfile {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "authfile";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = REDEMPTION_CONFIG_AUTHFILE;
    };
    /// Time out during RDP handshake stage. <br/>
    /// type: std::chrono::seconds <br/>
    /// value{10} <br/>
    struct globals::handshake_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "handshake_timeout";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{10};
    };
    /// No traffic auto disconnection. <br/>
    /// type: std::chrono::seconds <br/>
    /// value{900} <br/>
    struct globals::session_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "session_timeout";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{900};
    };
    /// No traffic auto disconnection. <br/>
    /// If value is 0, global value (session_timeout) is used. <br/>
    /// type: std::chrono::seconds <br/>
    /// sesman -> proxy <br/>
    /// value{0} <br/>
    struct globals::inactivity_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "inactivity_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(11);
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// Keepalive. <br/>
    /// type: std::chrono::seconds <br/>
    /// value{30} <br/>
    struct globals::keepalive_grace_delay {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "keepalive_grace_delay";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{30};
    };
    /// Specifies the time to spend on the login screen of proxy RDP before closing client window (0 to desactivate). <br/>
    /// type: std::chrono::seconds <br/>
    /// value{120} <br/>
    struct globals::authentication_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "authentication_timeout";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{120};
    };
    /// Specifies the time to spend on the close box of proxy RDP before closing client window (0 to desactivate). <br/>
    /// type: std::chrono::seconds <br/>
    /// value{600} <br/>
    struct globals::close_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "close_timeout";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{600};
    };
    /// type: TraceType <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(1) <br/>
    struct globals::trace_type {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "trace_type";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(12);
        using type = TraceType;
        using sesman_and_spec_type = TraceType;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// type: std::string <br/>
    /// value = "0.0.0.0" <br/>
    struct globals::listen_address {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "listen_address";
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::ip;
        using mapped_type = sesman_and_spec_type;
        type value = "0.0.0.0";
    };
    /// Allow Transparent mode. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::enable_transparent_mode {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_transparent_mode";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Proxy certificate password. <br/>
    /// type: char[255] <br/>
    /// value = "inquisition" <br/>
    struct globals::certificate_password {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "certificate_password";
        using type = char[255];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "inquisition";
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// value = app_path(AppPath::Png) <br/>
    struct globals::png_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "png_path";
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::Png);
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// value = app_path(AppPath::Wrm) <br/>
    struct globals::wrm_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "wrm_path";
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::Wrm);
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct globals::is_rec {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "is_rec";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(13);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct globals::movie_path {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "movie_path";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(14);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Support of Bitmap Update. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::enable_bitmap_update {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_bitmap_update";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Show close screen. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::enable_close_box {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_close_box";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::enable_osd {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_osd";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::enable_osd_display_remote_target {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_osd_display_remote_target";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// value = app_path(AppPath::Persistent) <br/>
    struct globals::persistent_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "persistent_path";
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::Persistent);
    };
    /// type: bool <br/>
    /// value = REDEMPTION_CONFIG_ENABLE_WAB_INTEGRATION <br/>
    struct globals::enable_wab_integration {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_wab_integration";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value = REDEMPTION_CONFIG_ENABLE_WAB_INTEGRATION;
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::allow_using_multiple_monitors {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "allow_using_multiple_monitors";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Needed to refresh screen of Windows Server 2012. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::bogus_refresh_rect {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "bogus_refresh_rect";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: std::string <br/>
    /// value = "flv" <br/>
    struct globals::codec_id {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "codec_id";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "flv";
    };
    /// type: Level <br/>
    /// value = static_cast<type>(2) <br/>
    struct globals::video_quality {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "video_quality";
        using type = Level;
        using sesman_and_spec_type = Level;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(2);
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::large_pointer_support {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "large_pointer_support";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct globals::unicode_keyboard_event_support {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "unicode_keyboard_event_support";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(15);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{1000} <br/>
    struct globals::mod_recv_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "mod_recv_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(16);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 100, 10000>;
        using mapped_type = sesman_and_spec_type;
        type value{1000};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::spark_view_specific_glyph_width {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "spark_view_specific_glyph_width";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::experimental_enable_serializer_data_block_size_limit {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "experimental_enable_serializer_data_block_size_limit";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::experimental_support_resize_session_during_recording {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "experimental_support_resize_session_during_recording";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Prevent Remote Desktop session timeouts due to idle tcp sessions by sending periodically keep alive packet to client. <br/>
    /// !!!May cause FreeRDP-based client to CRASH!!! <br/>
    /// Set to 0 to disable this feature. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// value{0} <br/>
    struct globals::rdp_keepalive_connection_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "rdp_keepalive_connection_interval";
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };

    /// type: bool <br/>
    /// value{true} <br/>
    struct session_log::enable_session_log {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "session_log";
        static constexpr char const * name = "enable_session_log";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct session_log::enable_arcsight_log {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "session_log";
        static constexpr char const * name = "enable_arcsight_log";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct session_log::log_path {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "session_log";
        static constexpr char const * name = "log_path";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(17);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: KeyboardInputMaskingLevel <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(2) <br/>
    struct session_log::keyboard_input_masking_level {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "session_log";
        static constexpr char const * name = "keyboard_input_masking_level";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(18);
        using type = KeyboardInputMaskingLevel;
        using sesman_and_spec_type = KeyboardInputMaskingLevel;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(2);
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct session_log::hide_non_printable_kbd_input {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "session_log";
        static constexpr char const * name = "hide_non_printable_kbd_input";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// type: unsigned int <br/>
    /// sesman <- proxy <br/>
    /// value{0} <br/>
    struct client::keyboard_layout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "client";
        static constexpr char const * name = "keyboard_layout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(19);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// cs-CZ, da-DK, de-DE, el-GR, en-US, es-ES, fi-FI.finnish, fr-FR, is-IS, it-IT, nl-NL, nb-NO, pl-PL.programmers, pt-BR.abnt, ro-RO, ru-RU, hr-HR, sk-SK, sv-SE, tr-TR.q, uk-UA, sl-SI, et-EE, lv-LV, lt-LT.ibm, mk-MK, fo-FO, mt-MT.47, se-NO, kk-KZ, ky-KG, tt-RU, mn-MN, cy-GB, lb-LU, mi-NZ, de-CH, en-GB, es-MX, fr-BE.fr, nl-BE, pt-PT, sr-La, se-SE, uz-Cy, iu-La, fr-CA, sr-Cy, en-CA.fr, fr-CH, bs-Cy, bg-BG.latin, cs-CZ.qwerty, en-IE.irish, de-DE.ibm, el-GR.220, es-ES.variation, hu-HU, en-US.dvorak, it-IT.142, pl-PL, pt-BR.abnt2, ru-RU.typewriter, sk-SK.qwerty, tr-TR.f, lv-LV.qwerty, lt-LT, mt-MT.48, se-NO.ext_norway, fr-BE, se-SE, en-CA.multilingual, en-IE, cs-CZ.programmers, el-GR.319, en-US.international, se-SE.ext_finland_sweden, bg-BG, el-GR.220_latin, en-US.dvorak_left, el-GR.319_latin, en-US.dvorak_right, el-GR.latin, el-GR.polytonic <br/>
    /// type: std::string <br/>
    /// value = "en-US, fr-FR, de-DE, ru-RU" <br/>
    struct client::keyboard_layout_proposals {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "keyboard_layout_proposals";
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value = "en-US, fr-FR, de-DE, ru-RU";
    };
    /// If true, ignore password provided by RDP client, user need do login manually. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::ignore_logon_password {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "ignore_logon_password";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Enable font smoothing (0x80). <br/>
    /// type: uint32_t <br/>
    /// value{128} <br/>
    struct client::performance_flags_default {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "performance_flags_default";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{128};
    };
    /// Disable theme (0x8). <br/>
    /// Disable mouse cursor shadows (0x20). <br/>
    /// type: uint32_t <br/>
    /// value{40} <br/>
    struct client::performance_flags_force_present {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "performance_flags_force_present";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{40};
    };
    /// type: uint32_t <br/>
    /// value{0} <br/>
    struct client::performance_flags_force_not_present {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "performance_flags_force_not_present";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// If enabled, avoid automatically font smoothing in recorded session. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::auto_adjust_performance_flags {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "auto_adjust_performance_flags";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Fallback to RDP Legacy Encryption if client does not support TLS. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::tls_fallback_legacy {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "tls_fallback_legacy";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::tls_support {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "tls_support";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Needed to connect with jrdp, based on bogus X224 layer code. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::bogus_neg_request {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bogus_neg_request";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Needed to connect with Remmina 0.8.3 and freerdp 0.9.4, based on bogus MCS layer code. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::bogus_user_id {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bogus_user_id";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// If enabled, ignore CTRL+ALT+DEL and CTRL+SHIFT+ESCAPE (or the equivalents) keyboard sequences. <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct client::disable_tsk_switch_shortcuts {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "disable_tsk_switch_shortcuts";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(20);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: RdpCompression <br/>
    /// value = static_cast<type>(4) <br/>
    struct client::rdp_compression {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "rdp_compression";
        using type = RdpCompression;
        using sesman_and_spec_type = RdpCompression;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(4);
    };
    /// type: ColorDepth <br/>
    /// value = static_cast<type>(24) <br/>
    struct client::max_color_depth {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "max_color_depth";
        using type = ColorDepth;
        using sesman_and_spec_type = ColorDepth;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(24);
    };
    /// Persistent Disk Bitmap Cache on the front side. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::persistent_disk_bitmap_cache {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "persistent_disk_bitmap_cache";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Support of Cache Waiting List (this value is ignored if Persistent Disk Bitmap Cache is disabled). <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::cache_waiting_list {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "cache_waiting_list";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// If enabled, the contents of Persistent Bitmap Caches are stored on disk. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::persist_bitmap_cache_on_disk {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "persist_bitmap_cache_on_disk";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Support of Bitmap Compression. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::bitmap_compression {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bitmap_compression";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Enables support of Clent Fast-Path Input Event PDUs. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::fast_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "fast_path";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::enable_suppress_output {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "enable_suppress_output";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// [Not configured]: Compatible with more RDP clients (less secure) <br/>
    /// HIGH:!ADH:!3DES: Compatible only with MS Windows 7 client or more recent (moderately secure)HIGH:!ADH:!3DES:!SHA: Compatible only with MS Server Windows 2008 R2 client or more recent (more secure) <br/>
    /// type: std::string <br/>
    /// value = "HIGH:!ADH:!3DES:!SHA" <br/>
    struct client::ssl_cipher_list {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "ssl_cipher_list";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "HIGH:!ADH:!3DES:!SHA";
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::show_target_user_in_f12_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "show_target_user_in_f12_message";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::enable_new_pointer_update {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "enable_new_pointer_update";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::bogus_ios_glyph_support_level {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bogus_ios_glyph_support_level";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::transform_glyph_to_bitmap {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "transform_glyph_to_bitmap";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: BogusNumberOfFastpathInputEvent <br/>
    /// value = static_cast<type>(1) <br/>
    struct client::bogus_number_of_fastpath_input_event {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bogus_number_of_fastpath_input_event";
        using type = BogusNumberOfFastpathInputEvent;
        using sesman_and_spec_type = BogusNumberOfFastpathInputEvent;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// type: std::chrono::milliseconds <br/>
    /// value{1000} <br/>
    struct client::recv_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "recv_timeout";
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 100, 10000>;
        using mapped_type = sesman_and_spec_type;
        type value{1000};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::enable_osd_4_eyes {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "enable_osd_4_eyes";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// type: RdpCompression <br/>
    /// value = static_cast<type>(4) <br/>
    struct mod_rdp::rdp_compression {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "rdp_compression";
        using type = RdpCompression;
        using sesman_and_spec_type = RdpCompression;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(4);
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::disconnect_on_logon_user_change {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "disconnect_on_logon_user_change";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::chrono::seconds <br/>
    /// value{0} <br/>
    struct mod_rdp::open_session_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "open_session_timeout";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// Enables support of additional drawing orders: <br/>
    ///   15: MultiDstBlt <br/>
    ///   16: MultiPatBlt <br/>
    ///   17: MultiScrBlt <br/>
    ///   18: MultiOpaqueRect <br/>
    ///   22: Polyline <br/>
    /// type: std::string <br/>
    /// value = "15,16,17,18,22" <br/>
    struct mod_rdp::extra_orders {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "extra_orders";
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<unsigned int>;
        using mapped_type = sesman_and_spec_type;
        type value = "15,16,17,18,22";
    };
    /// NLA authentication in secondary target. <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::enable_nla {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_nla";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(21);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// If enabled, NLA authentication will try Kerberos before NTLM. <br/>
    /// (if enable_nla is disabled, this value is ignored). <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::enable_kerberos {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_kerberos";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(22);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Persistent Disk Bitmap Cache on the mod side. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::persistent_disk_bitmap_cache {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "persistent_disk_bitmap_cache";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Support of Cache Waiting List (this value is ignored if Persistent Disk Bitmap Cache is disabled). <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::cache_waiting_list {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "cache_waiting_list";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// If enabled, the contents of Persistent Bitmap Caches are stored on disk. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::persist_bitmap_cache_on_disk {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "persist_bitmap_cache_on_disk";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Enables channels names (example: channel1,channel2,etc). Character * only, activate all with low priority. <br/>
    /// type: std::string <br/>
    /// value = "*" <br/>
    struct mod_rdp::allow_channels {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "allow_channels";
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value = "*";
    };
    /// Disable channels names (example: channel1,channel2,etc). Character * only, deactivate all with low priority. <br/>
    /// type: std::string <br/>
    /// value{} <br/>
    struct mod_rdp::deny_channels {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "deny_channels";
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Enables support of Client/Server Fast-Path Input/Update PDUs. <br/>
    /// Fast-Path is required for Windows Server 2012 (or more recent)! <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::fast_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "fast_path";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Enables Server Redirection Support. <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::server_redirection_support {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_redirection_support";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(23);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: RedirectionInfo <br/>
    /// value{} <br/>
    struct mod_rdp::redir_info {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "redir_info";
        using type = RedirectionInfo;
        using mapped_type = type;
        type value{};
    };
    /// Load balancing information <br/>
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct mod_rdp::load_balance_info {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "load_balance_info";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(24);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Needed to connect with VirtualBox, based on bogus TS_UD_SC_NET data block. <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::bogus_sc_net_size {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "bogus_sc_net_size";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(25);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct mod_rdp::proxy_managed_drives {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "proxy_managed_drives";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(26);
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::ignore_auth_channel {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "ignore_auth_channel";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(27);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Authentication channel used by Auto IT scripts. May be '*' to use default name. Keep empty to disable virtual channel. <br/>
    /// type: char[8] <br/>
    /// value = "*" <br/>
    struct mod_rdp::auth_channel {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "auth_channel";
        using type = char[8];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "*";
    };
    /// Authentication channel used by other scripts. No default name. Keep empty to disable virtual channel. <br/>
    /// type: char[8] <br/>
    /// value = "" <br/>
    struct mod_rdp::checkout_channel {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "checkout_channel";
        using type = char[8];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "";
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct mod_rdp::alternate_shell {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "alternate_shell";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(28);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct mod_rdp::shell_arguments {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "shell_arguments";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(29);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct mod_rdp::shell_working_directory {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "shell_working_directory";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(30);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// As far as possible, use client-provided initial program (Alternate Shell) <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::use_client_provided_alternate_shell {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "use_client_provided_alternate_shell";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(31);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// As far as possible, use client-provided remote program (RemoteApp) <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::use_client_provided_remoteapp {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "use_client_provided_remoteapp";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(32);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// As far as possible, use native RemoteApp capability <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::use_native_remoteapp_capability {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "use_native_remoteapp_capability";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(33);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::enable_session_probe {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_session_probe";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(34);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Minimum supported server : Windows Server 2008. <br/>
    /// Clipboard redirection should be remain enabled on Terminal Server. <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_use_clipboard_based_launcher {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_use_clipboard_based_launcher";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(35);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_enable_launch_mask {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_enable_launch_mask";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(36);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: SessionProbeOnLaunchFailure <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(2) <br/>
    struct mod_rdp::session_probe_on_launch_failure {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_on_launch_failure";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(37);
        using type = SessionProbeOnLaunchFailure;
        using sesman_and_spec_type = SessionProbeOnLaunchFailure;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(2);
    };
    /// This parameter is used if session_probe_on_launch_failure is 1 (disconnect user). <br/>
    /// 0 to disable timeout. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{40000} <br/>
    struct mod_rdp::session_probe_launch_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_launch_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(38);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 300000>;
        using mapped_type = sesman_and_spec_type;
        type value{40000};
    };
    /// This parameter is used if session_probe_on_launch_failure is 0 (ignore failure and continue) or 2 (reconnect without Session Probe). <br/>
    /// 0 to disable timeout. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{10000} <br/>
    struct mod_rdp::session_probe_launch_fallback_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_launch_fallback_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(39);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 300000>;
        using mapped_type = sesman_and_spec_type;
        type value{10000};
    };
    /// Minimum supported server : Windows Server 2008. <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_start_launch_timeout_timer_only_after_logon {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_start_launch_timeout_timer_only_after_logon";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(40);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{5000} <br/>
    struct mod_rdp::session_probe_keepalive_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_keepalive_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(41);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 60000>;
        using mapped_type = sesman_and_spec_type;
        type value{5000};
    };
    /// type: SessionProbeOnKeepaliveTimeout <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::session_probe_on_keepalive_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_on_keepalive_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(42);
        using type = SessionProbeOnKeepaliveTimeout;
        using sesman_and_spec_type = SessionProbeOnKeepaliveTimeout;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// End automatically a disconnected session. <br/>
    /// Session Probe must be enabled to use this feature. <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_end_disconnected_session {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_end_disconnected_session";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(43);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_customize_executable_name {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_customize_executable_name";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_enable_log {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_enable_log";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(44);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_enable_log_rotation {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_enable_log_rotation";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(45);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// This policy setting allows you to configure a time limit for disconnected application sessions. <br/>
    /// 0 to disable timeout. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_disconnected_application_limit {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_disconnected_application_limit";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(46);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 172800000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// This policy setting allows you to configure a time limit for disconnected Terminal Services sessions. <br/>
    /// 0 to disable timeout. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_disconnected_session_limit {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_disconnected_session_limit";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(47);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 172800000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// This parameter allows you to specify the maximum amount of time that an active Terminal Services session can be idle (without user input) before it is automatically locked by Session Probe. <br/>
    /// 0 to disable timeout. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_idle_session_limit {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_idle_session_limit";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(48);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 172800000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: char[512] <br/>
    /// value = "||CMD" <br/>
    struct mod_rdp::session_probe_exe_or_file {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_exe_or_file";
        using type = char[512];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "||CMD";
    };
    /// type: char[512] <br/>
    /// value = REDEMPTION_CONFIG_SESSION_PROBE_ARGUMENTS <br/>
    struct mod_rdp::session_probe_arguments {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_arguments";
        using type = char[512];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = REDEMPTION_CONFIG_SESSION_PROBE_ARGUMENTS;
    };
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{2000} <br/>
    struct mod_rdp::session_probe_clipboard_based_launcher_clipboard_initialization_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_clipboard_based_launcher_clipboard_initialization_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(49);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{2000};
    };
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_clipboard_based_launcher_start_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_clipboard_based_launcher_start_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(50);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{500} <br/>
    struct mod_rdp::session_probe_clipboard_based_launcher_long_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_clipboard_based_launcher_long_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(51);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{500};
    };
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{50} <br/>
    struct mod_rdp::session_probe_clipboard_based_launcher_short_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_clipboard_based_launcher_short_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(52);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{50};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_allow_multiple_handshake {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_allow_multiple_handshake";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_enable_crash_dump {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_enable_crash_dump";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(53);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: uint32_t <br/>
    /// sesman -> proxy <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_handle_usage_limit {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_handle_usage_limit";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(54);
        using type = uint32_t;
        using sesman_and_spec_type = ::configs::spec_types::range<uint32_t, 0, 1000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: uint32_t <br/>
    /// sesman -> proxy <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_memory_usage_limit {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_memory_usage_limit";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(55);
        using type = uint32_t;
        using sesman_and_spec_type = ::configs::spec_types::range<uint32_t, 0, 200000000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_ignore_ui_less_processes_during_end_of_session_check {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_ignore_ui_less_processes_during_end_of_session_check";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(56);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_childless_window_as_unidentified_input_field {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_childless_window_as_unidentified_input_field";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(57);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// If enabled, disconnected session can be recovered by a different primary user. <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_public_session {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_public_session";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(58);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Keep known server certificates on WAB <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::server_cert_store {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_store";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(59);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: ServerCertCheck <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_cert_check {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_check";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(60);
        using type = ServerCertCheck;
        using sesman_and_spec_type = ServerCertCheck;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Warn if check allow connexion to server. <br/>
    /// type: ServerNotification <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_access_allowed_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_access_allowed_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(61);
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Warn that new server certificate file was created. <br/>
    /// type: ServerNotification <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_cert_create_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_create_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(62);
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Warn that server certificate file was successfully checked. <br/>
    /// type: ServerNotification <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_cert_success_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_success_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(63);
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Warn that server certificate file checking failed. <br/>
    /// type: ServerNotification <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_cert_failure_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_failure_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(64);
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Warn that server certificate check raised some internal error. <br/>
    /// type: ServerNotification <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_cert_error_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_error_message";
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Do not transmit client machine name or RDP server. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::hide_client_name {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "hide_client_name";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::clean_up_32_bpp_cursor {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "clean_up_32_bpp_cursor";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::bogus_ios_rdpdr_virtual_channel {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "bogus_ios_rdpdr_virtual_channel";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::enable_rdpdr_data_analysis {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_rdpdr_data_analysis";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(65);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Delay before automatically bypass Windows's Legal Notice screen in RemoteApp mode. <br/>
    /// Set to 0 to disable this feature. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// value{0} <br/>
    struct mod_rdp::remoteapp_bypass_legal_notice_delay {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "remoteapp_bypass_legal_notice_delay";
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// Time limit to automatically bypass Windows's Legal Notice screen in RemoteApp mode. <br/>
    /// Set to 0 to disable this feature. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// value{20000} <br/>
    struct mod_rdp::remoteapp_bypass_legal_notice_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "remoteapp_bypass_legal_notice_timeout";
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{20000};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::log_only_relevant_clipboard_activities {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "log_only_relevant_clipboard_activities";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::experimental_fix_input_event_sync {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "experimental_fix_input_event_sync";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::experimental_fix_too_long_cookie {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "experimental_fix_too_long_cookie";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };

    /// type: bool <br/>
    /// value{false} <br/>
    struct metrics::enable_rdp_metrics {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "enable_rdp_metrics";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct metrics::enable_vnc_metrics {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "enable_vnc_metrics";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// value = app_path(AppPath::Metrics) <br/>
    struct metrics::log_dir_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "log_dir_path";
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::Metrics);
    };
    /// type: std::chrono::seconds <br/>
    /// value{5} <br/>
    struct metrics::log_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "log_interval";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    /// type: std::chrono::hours <br/>
    /// value{24} <br/>
    struct metrics::log_file_turnover_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "log_file_turnover_interval";
        using type = std::chrono::hours;
        using sesman_and_spec_type = std::chrono::hours;
        using mapped_type = sesman_and_spec_type;
        type value{24};
    };
    /// signature key to digest log metrics header info <br/>
    /// type: std::string <br/>
    /// value = "" <br/>
    struct metrics::sign_key {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "sign_key";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "";
    };

    /// Enable or disable the clipboard from client (client to server). <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct mod_vnc::clipboard_up {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "clipboard_up";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(66);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Enable or disable the clipboard from server (server to client). <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct mod_vnc::clipboard_down {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "clipboard_down";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(67);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Sets the encoding types in which pixel data can be sent by the VNC server: <br/>
    ///   0: Raw <br/>
    ///   1: CopyRect <br/>
    ///   2: RRE <br/>
    ///   16: ZRLE <br/>
    ///   -239 (0xFFFFFF11): Cursor pseudo-encoding <br/>
    /// type: std::string <br/>
    /// value{} <br/>
    struct mod_vnc::encodings {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "encodings";
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<int>;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// VNC server clipboard data encoding type. <br/>
    /// type: ClipboardEncodingType <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_vnc::server_clipboard_encoding_type {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "server_clipboard_encoding_type";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(68);
        using type = ClipboardEncodingType;
        using sesman_and_spec_type = ClipboardEncodingType;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// type: VncBogusClipboardInfiniteLoop <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(0) <br/>
    struct mod_vnc::bogus_clipboard_infinite_loop {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "bogus_clipboard_infinite_loop";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(69);
        using type = VncBogusClipboardInfiniteLoop;
        using sesman_and_spec_type = VncBogusClipboardInfiniteLoop;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_vnc::server_is_apple {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "server_is_apple";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(70);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_vnc::server_unix_alt {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "server_unix_alt";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(71);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// 0 - Wait for Escape, 1 - End session <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_replay::on_end_of_data {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_replay";
        static constexpr char const * name = "on_end_of_data";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// 0 - replay once, 1 - loop replay <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct mod_replay::replay_on_loop {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_replay";
        static constexpr char const * name = "replay_on_loop";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(72);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// type: OcrVersion <br/>
    /// value = static_cast<type>(2) <br/>
    struct ocr::version {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "ocr";
        static constexpr char const * name = "version";
        using type = OcrVersion;
        using sesman_and_spec_type = OcrVersion;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(2);
    };
    /// type: OcrLocale <br/>
    /// value = static_cast<type>(0) <br/>
    struct ocr::locale {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "ocr";
        static constexpr char const * name = "locale";
        using type = OcrLocale;
        using sesman_and_spec_type = OcrLocale;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// type: std::chrono::duration<unsigned, std::ratio<1, 100>> <br/>
    /// value{100} <br/>
    struct ocr::interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "ocr";
        static constexpr char const * name = "interval";
        using type = std::chrono::duration<unsigned, std::ratio<1, 100>>;
        using sesman_and_spec_type = std::chrono::duration<unsigned, std::ratio<1, 100>>;
        using mapped_type = sesman_and_spec_type;
        type value{100};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct ocr::on_title_bar_only {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "ocr";
        static constexpr char const * name = "on_title_bar_only";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Expressed in percentage, <br/>
    ///   0   - all of characters need be recognized <br/>
    ///   100 - accept all results <br/>
    /// type: unsigned int <br/>
    /// value{40} <br/>
    struct ocr::max_unrecog_char_rate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "ocr";
        static constexpr char const * name = "max_unrecog_char_rate";
        using type = unsigned int;
        using sesman_and_spec_type = ::configs::spec_types::range<unsigned int, 0, 100>;
        using mapped_type = sesman_and_spec_type;
        type value{40};
    };

    /// type: unsigned int <br/>
    /// value{33} <br/>
    struct video::capture_groupid {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "capture_groupid";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{33};
    };
    /// type: CaptureFlags <br/>
    /// value = static_cast<type>(11) <br/>
    struct video::capture_flags {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "capture_flags";
        using type = CaptureFlags;
        using sesman_and_spec_type = CaptureFlags;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(11);
    };
    /// Frame interval. <br/>
    /// type: std::chrono::duration<unsigned, std::ratio<1, 10>> <br/>
    /// value{10} <br/>
    struct video::png_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "png_interval";
        using type = std::chrono::duration<unsigned, std::ratio<1, 10>>;
        using sesman_and_spec_type = std::chrono::duration<unsigned, std::ratio<1, 10>>;
        using mapped_type = sesman_and_spec_type;
        type value{10};
    };
    /// Frame interval. <br/>
    /// type: std::chrono::duration<unsigned, std::ratio<1, 100>> <br/>
    /// value{40} <br/>
    struct video::frame_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "frame_interval";
        using type = std::chrono::duration<unsigned, std::ratio<1, 100>>;
        using sesman_and_spec_type = std::chrono::duration<unsigned, std::ratio<1, 100>>;
        using mapped_type = sesman_and_spec_type;
        type value{40};
    };
    /// Time between 2 wrm movies. <br/>
    /// type: std::chrono::seconds <br/>
    /// value{600} <br/>
    struct video::break_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "break_interval";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{600};
    };
    /// Number of png captures to keep. <br/>
    /// type: unsigned int <br/>
    /// value{5} <br/>
    struct video::png_limit {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "png_limit";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// value = "/tmp/" <br/>
    struct video::replay_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "replay_path";
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = "/tmp/";
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// value = app_path(AppPath::Hash) <br/>
    struct video::hash_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "hash_path";
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::Hash);
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// value = app_path(AppPath::RecordTmp) <br/>
    struct video::record_tmp_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "record_tmp_path";
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::RecordTmp);
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// value = app_path(AppPath::Record) <br/>
    struct video::record_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "record_path";
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::Record);
    };
    /// Disable keyboard log: <br/>
    /// type: KeyboardLogFlags <br/>
    /// value = static_cast<type>(1) <br/>
    struct video::disable_keyboard_log {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "disable_keyboard_log";
        using type = KeyboardLogFlags;
        using sesman_and_spec_type = KeyboardLogFlags;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Disable clipboard log: <br/>
    /// type: ClipboardLogFlags <br/>
    /// value = static_cast<type>(1) <br/>
    struct video::disable_clipboard_log {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "disable_clipboard_log";
        using type = ClipboardLogFlags;
        using sesman_and_spec_type = ClipboardLogFlags;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Disable (redirected) file system log: <br/>
    /// type: FileSystemLogFlags <br/>
    /// value = static_cast<type>(1) <br/>
    struct video::disable_file_system_log {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "disable_file_system_log";
        using type = FileSystemLogFlags;
        using sesman_and_spec_type = FileSystemLogFlags;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct video::rt_display {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "rt_display";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(73);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: ColorDepthSelectionStrategy <br/>
    /// value = static_cast<type>(1) <br/>
    struct video::wrm_color_depth_selection_strategy {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "wrm_color_depth_selection_strategy";
        using type = ColorDepthSelectionStrategy;
        using sesman_and_spec_type = ColorDepthSelectionStrategy;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// type: WrmCompressionAlgorithm <br/>
    /// value = static_cast<type>(1) <br/>
    struct video::wrm_compression_algorithm {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "wrm_compression_algorithm";
        using type = WrmCompressionAlgorithm;
        using sesman_and_spec_type = WrmCompressionAlgorithm;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Needed to play a video with ffplay or VLC. <br/>
    /// Note: Useless with mpv and mplayer. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct video::bogus_vlc_frame_rate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "bogus_vlc_frame_rate";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Bitrate for low quality. <br/>
    /// type: unsigned int <br/>
    /// value{10000} <br/>
    struct video::l_bitrate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "l_bitrate";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{10000};
    };
    /// Framerate for low quality. <br/>
    /// type: unsigned int <br/>
    /// value{5} <br/>
    struct video::l_framerate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "l_framerate";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    /// Height for low quality. <br/>
    /// type: unsigned int <br/>
    /// value{480} <br/>
    struct video::l_height {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "l_height";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{480};
    };
    /// Width for low quality. <br/>
    /// type: unsigned int <br/>
    /// value{640} <br/>
    struct video::l_width {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "l_width";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{640};
    };
    /// Qscale (parameter given to ffmpeg) for low quality. <br/>
    /// type: unsigned int <br/>
    /// value{28} <br/>
    struct video::l_qscale {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "l_qscale";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{28};
    };
    /// Bitrate for medium quality. <br/>
    /// type: unsigned int <br/>
    /// value{20000} <br/>
    struct video::m_bitrate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "m_bitrate";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{20000};
    };
    /// Framerate for medium quality. <br/>
    /// type: unsigned int <br/>
    /// value{5} <br/>
    struct video::m_framerate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "m_framerate";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    /// Height for medium quality. <br/>
    /// type: unsigned int <br/>
    /// value{768} <br/>
    struct video::m_height {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "m_height";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{768};
    };
    /// Width for medium quality. <br/>
    /// type: unsigned int <br/>
    /// value{1024} <br/>
    struct video::m_width {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "m_width";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{1024};
    };
    /// Qscale (parameter given to ffmpeg) for medium quality. <br/>
    /// type: unsigned int <br/>
    /// value{14} <br/>
    struct video::m_qscale {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "m_qscale";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{14};
    };
    /// Bitrate for high quality. <br/>
    /// type: unsigned int <br/>
    /// value{30000} <br/>
    struct video::h_bitrate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "h_bitrate";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{30000};
    };
    /// Framerate for high quality. <br/>
    /// type: unsigned int <br/>
    /// value{5} <br/>
    struct video::h_framerate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "h_framerate";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    /// Height for high quality. <br/>
    /// type: unsigned int <br/>
    /// value{2048} <br/>
    struct video::h_height {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "h_height";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{2048};
    };
    /// Width for high quality. <br/>
    /// type: unsigned int <br/>
    /// value{2048} <br/>
    struct video::h_width {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "h_width";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{2048};
    };
    /// Qscale (parameter given to ffmpeg) for high quality. <br/>
    /// type: unsigned int <br/>
    /// value{7} <br/>
    struct video::h_qscale {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "h_qscale";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{7};
    };
    /// type: SmartVideoCropping <br/>
    /// value = static_cast<type>(0) <br/>
    struct video::smart_video_cropping {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "smart_video_cropping";
        using type = SmartVideoCropping;
        using sesman_and_spec_type = SmartVideoCropping;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// Needed to play a video with corrupted Bitmap Update. <br/>
    /// Note: Useless with mpv and mplayer. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct video::play_video_with_corrupted_bitmap {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "play_video_with_corrupted_bitmap";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// type: std::array<unsigned char, 32> <br/>
    /// sesman -> proxy <br/>
    /// value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }} <br/>
    struct crypto::key0 {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "crypto";
        static constexpr char const * name = "key0";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(74);
        using type = std::array<unsigned char, 32>;
        using sesman_and_spec_type = ::configs::spec_types::fixed_binary;
        using mapped_type = sesman_and_spec_type;
        type value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }};
    };
    /// type: std::array<unsigned char, 32> <br/>
    /// sesman -> proxy <br/>
    /// value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }} <br/>
    struct crypto::key1 {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "crypto";
        static constexpr char const * name = "key1";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(75);
        using type = std::array<unsigned char, 32>;
        using sesman_and_spec_type = ::configs::spec_types::fixed_binary;
        using mapped_type = sesman_and_spec_type;
        type value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }};
    };

    /// type: std::string <br/>
    /// value{} <br/>
    struct debug::fake_target_ip {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "fake_target_ip";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::x224 {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "x224";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::mcs {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "mcs";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::sec {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "sec";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::rdp {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "rdp";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::primary_orders {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "primary_orders";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::secondary_orders {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "secondary_orders";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::bitmap_update {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "bitmap_update";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::bitmap {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "bitmap";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::capture {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "capture";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::auth {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "auth";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::session {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "session";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::front {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "front";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::mod_rdp {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "mod_rdp";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::mod_vnc {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "mod_vnc";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::mod_internal {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "mod_internal";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::mod_xup {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "mod_xup";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::widget {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "widget";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::input {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "input";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::password {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "password";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::compression {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "compression";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::cache {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "cache";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::performance {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "performance";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::pass_dialog_box {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "pass_dialog_box";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::ocr {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "ocr";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::ffmpeg {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "ffmpeg";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// value{2} <br/>
    struct debug::config {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "config";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{2};
    };

    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct remote_program::allow_resize_hosted_desktop {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "remote_program";
        static constexpr char const * name = "allow_resize_hosted_desktop";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(76);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };

    /// type: Language <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(0) <br/>
    struct translation::language {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "translation";
        static constexpr char const * name = "language";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(77);
        using type = Language;
        using sesman_and_spec_type = Language;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct translation::password_en {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "translation";
        static constexpr char const * name = "password_en";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(78);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct translation::password_fr {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "translation";
        static constexpr char const * name = "password_fr";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(79);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };

    /// type: std::string <br/>
    /// value{} <br/>
    struct internal_mod::theme {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "internal_mod";
        static constexpr char const * name = "theme";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };

    /// type: std::string <br/>
    /// sesman <- proxy <br/>
    /// value{} <br/>
    struct context::psid {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "psid";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(80);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman -> proxy <br/>
    /// value{40000} <br/>
    struct context::opt_bitrate {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_bitrate";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(81);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{40000};
    };
    /// type: unsigned int <br/>
    /// sesman -> proxy <br/>
    /// value{5} <br/>
    struct context::opt_framerate {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_framerate";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(82);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    /// type: unsigned int <br/>
    /// sesman -> proxy <br/>
    /// value{15} <br/>
    struct context::opt_qscale {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_qscale";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(83);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{15};
    };
    /// type: ColorDepth <br/>
    /// sesman <-> proxy <br/>
    /// value = static_cast<type>(24) <br/>
    struct context::opt_bpp {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_bpp";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(84);
        using type = ColorDepth;
        using sesman_and_spec_type = ColorDepth;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(24);
    };
    /// type: uint16_t <br/>
    /// sesman <-> proxy <br/>
    /// value{600} <br/>
    struct context::opt_height {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_height";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(85);
        using type = uint16_t;
        using sesman_and_spec_type = uint16_t;
        using mapped_type = sesman_and_spec_type;
        type value{600};
    };
    /// type: uint16_t <br/>
    /// sesman <-> proxy <br/>
    /// value{800} <br/>
    struct context::opt_width {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_width";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(86);
        using type = uint16_t;
        using sesman_and_spec_type = uint16_t;
        using mapped_type = sesman_and_spec_type;
        type value{800};
    };
    /// type: std::string <br/>
    /// value{} <br/>
    struct context::auth_error_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_error_message";
        using type = std::string;
        using mapped_type = type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct context::selector {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(87);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: unsigned int <br/>
    /// sesman <-> proxy <br/>
    /// value{1} <br/>
    struct context::selector_current_page {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_current_page";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(88);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::selector_device_filter {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_device_filter";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(89);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::selector_group_filter {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_group_filter";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(90);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::selector_proto_filter {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_proto_filter";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(91);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman <-> proxy <br/>
    /// value{0} <br/>
    struct context::selector_lines_per_page {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_lines_per_page";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(92);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: unsigned int <br/>
    /// sesman -> proxy <br/>
    /// value{1} <br/>
    struct context::selector_number_of_pages {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_number_of_pages";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(93);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::target_password {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_password";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(94);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::target_host {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_host";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(95);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::target_str {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_str";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(96);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::target_service {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_service";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(97);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman <-> proxy <br/>
    /// value{3389} <br/>
    struct context::target_port {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_port";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(98);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{3389};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value = "RDP" <br/>
    struct context::target_protocol {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_protocol";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(99);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "RDP";
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::password {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "password";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(100);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::reporting {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "reporting";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(101);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::auth_channel_answer {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_channel_answer";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(102);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::auth_channel_target {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_channel_target";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(103);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(104);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman <- proxy <br/>
    /// value{} <br/>
    struct context::accept_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "accept_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(105);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::display_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "display_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(106);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::rejected {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rejected";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(107);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman <-> proxy <br/>
    /// value{false} <br/>
    struct context::authenticated {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "authenticated";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(108);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct context::keepalive {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "keepalive";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(109);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::session_id {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_id";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(110);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman -> proxy <br/>
    /// value{0} <br/>
    struct context::end_date_cnx {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "end_date_cnx";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(111);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::end_time {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "end_time";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(112);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: RdpModeConsole <br/>
    /// sesman -> proxy <br/>
    /// value = static_cast<type>(0) <br/>
    struct context::mode_console {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "mode_console";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(113);
        using type = RdpModeConsole;
        using sesman_and_spec_type = RdpModeConsole;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// type: int <br/>
    /// sesman -> proxy <br/>
    /// value{-3600} <br/>
    struct context::timezone {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "timezone";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(114);
        using type = int;
        using sesman_and_spec_type = int;
        using mapped_type = sesman_and_spec_type;
        type value{-3600};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::real_target_device {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "real_target_device";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(115);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::authentication_challenge {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "authentication_challenge";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(116);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::ticket {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "ticket";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(117);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::comment {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "comment";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(118);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::duration {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "duration";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(119);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman -> proxy <br/>
    /// value{0} <br/>
    struct context::duration_max {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "duration_max";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(120);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value{} <br/>
    struct context::waitinforeturn {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "waitinforeturn";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(121);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct context::showform {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "showform";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(122);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: unsigned int <br/>
    /// sesman <-> proxy <br/>
    /// value{0} <br/>
    struct context::formflag {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "formflag";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(123);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: std::string <br/>
    /// sesman <-> proxy <br/>
    /// value = "login" <br/>
    struct context::module {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "module";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(124);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "login";
    };
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{false} <br/>
    struct context::forcemodule {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "forcemodule";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(125);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::proxy_opt {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "proxy_opt";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(126);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::pattern_kill {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "pattern_kill";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(127);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::pattern_notify {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "pattern_notify";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(128);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::opt_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(129);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::login_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "login_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(130);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Comma-separated rules (Ex.: $deny:192.168.0.0/24:*,$allow:host.domain.net:3389,$allow:192.168.0.110:*) <br/>
    /// (Ex. for backwards compatibility only: 10.1.0.0/16:22) <br/>
    /// Session Probe must be enabled to use this feature. <br/>
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::session_probe_outbound_connection_monitoring_rules {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_probe_outbound_connection_monitoring_rules";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(131);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Comma-separated rules (Ex.: $deny:Taskmgr) <br/>
    /// @ = All child processes of Bastion Application (Ex.: $deny:@) <br/>
    /// Session Probe must be enabled to use this feature. <br/>
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::session_probe_process_monitoring_rules {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_probe_process_monitoring_rules";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(132);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Comma-separated extra system processes (Ex.: dllhos.exe,TSTheme.exe) <br/>
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::session_probe_extra_system_processes {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_probe_extra_system_processes";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(133);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Comma-separated processes (Ex.: chrome.exe,ngf.exe) <br/>
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::session_probe_windows_of_these_applications_as_unidentified_input_field {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_probe_windows_of_these_applications_as_unidentified_input_field";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(134);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::disconnect_reason {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "disconnect_reason";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(135);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman <- proxy <br/>
    /// value{false} <br/>
    struct context::disconnect_reason_ack {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "disconnect_reason_ack";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(136);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// value{} <br/>
    struct context::ip_target {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "ip_target";
        using type = std::string;
        using mapped_type = type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman <- proxy <br/>
    /// value{false} <br/>
    struct context::recording_started {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "recording_started";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(137);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// sesman <-> proxy <br/>
    /// value{false} <br/>
    struct context::rt_ready {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rt_ready";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(138);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct context::perform_automatic_reconnection {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "perform_automatic_reconnection";
        using type = bool;
        using mapped_type = type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::auth_command {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(139);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <- proxy <br/>
    /// value{} <br/>
    struct context::auth_notify {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_notify";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(140);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman <- proxy <br/>
    /// value{} <br/>
    struct context::auth_notify_rail_exec_flags {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_notify_rail_exec_flags";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(141);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <- proxy <br/>
    /// value{} <br/>
    struct context::auth_notify_rail_exec_exe_or_file {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_notify_rail_exec_exe_or_file";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(142);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_exec_result {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_exec_result";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(143);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_flags {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_flags";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(144);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_original_exe_or_file {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_original_exe_or_file";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(145);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_exe_or_file {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_exe_or_file";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(146);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_working_dir {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_working_dir";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(147);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_arguments {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_arguments";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(148);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_account {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_account";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(149);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_password {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_password";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(150);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Delay before showing disconnect message after the last RemoteApp window is closed. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// sesman -> proxy <br/>
    /// value{3000} <br/>
    struct context::rail_disconnect_message_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rail_disconnect_message_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(151);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{3000};
    };
    /// Use Session Probe to launch Remote Program as much as possible. <br/>
    /// type: bool <br/>
    /// sesman -> proxy <br/>
    /// value{true} <br/>
    struct context::use_session_probe_to_launch_remote_program {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "use_session_probe_to_launch_remote_program";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(152);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: std::string <br/>
    /// sesman <- proxy <br/>
    /// value{} <br/>
    struct context::session_probe_launch_error_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_probe_launch_error_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(153);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// value{} <br/>
    struct context::close_box_extra_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "close_box_extra_message";
        using type = std::string;
        using mapped_type = type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman -> proxy <br/>
    /// value{} <br/>
    struct context::pm_response {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "pm_response";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(154);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman <- proxy <br/>
    /// value{} <br/>
    struct context::pm_request {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "pm_request";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(155);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };

} // namespace cfg

namespace cfg_section {
struct globals
: cfg::globals::auth_user
, cfg::globals::host
, cfg::globals::target
, cfg::globals::target_device
, cfg::globals::device_id
, cfg::globals::primary_user_id
, cfg::globals::target_user
, cfg::globals::target_application
, cfg::globals::target_application_account
, cfg::globals::target_application_password
, cfg::globals::authfile
, cfg::globals::handshake_timeout
, cfg::globals::session_timeout
, cfg::globals::inactivity_timeout
, cfg::globals::keepalive_grace_delay
, cfg::globals::authentication_timeout
, cfg::globals::close_timeout
, cfg::globals::movie_path
, cfg::globals::codec_id
, cfg::globals::rdp_keepalive_connection_interval
, cfg::globals::port
, cfg::globals::capture_chunk
, cfg::globals::bitmap_cache
, cfg::globals::glyph_cache
, cfg::globals::nomouse
, cfg::globals::notimestamp
, cfg::globals::encryptionLevel
, cfg::globals::trace_type
, cfg::globals::listen_address
, cfg::globals::enable_transparent_mode
, cfg::globals::certificate_password
, cfg::globals::png_path
, cfg::globals::wrm_path
, cfg::globals::is_rec
, cfg::globals::enable_bitmap_update
, cfg::globals::enable_close_box
, cfg::globals::enable_osd
, cfg::globals::enable_osd_display_remote_target
, cfg::globals::persistent_path
, cfg::globals::enable_wab_integration
, cfg::globals::allow_using_multiple_monitors
, cfg::globals::bogus_refresh_rect
, cfg::globals::video_quality
, cfg::globals::large_pointer_support
, cfg::globals::unicode_keyboard_event_support
, cfg::globals::mod_recv_timeout
, cfg::globals::spark_view_specific_glyph_width
, cfg::globals::experimental_enable_serializer_data_block_size_limit
, cfg::globals::experimental_support_resize_session_during_recording
{ static constexpr bool is_section = true; };

struct session_log
: cfg::session_log::log_path
, cfg::session_log::enable_session_log
, cfg::session_log::enable_arcsight_log
, cfg::session_log::keyboard_input_masking_level
, cfg::session_log::hide_non_printable_kbd_input
{ static constexpr bool is_section = true; };

struct client
: cfg::client::ssl_cipher_list
, cfg::client::keyboard_layout
, cfg::client::keyboard_layout_proposals
, cfg::client::ignore_logon_password
, cfg::client::performance_flags_default
, cfg::client::performance_flags_force_present
, cfg::client::performance_flags_force_not_present
, cfg::client::auto_adjust_performance_flags
, cfg::client::tls_fallback_legacy
, cfg::client::tls_support
, cfg::client::bogus_neg_request
, cfg::client::bogus_user_id
, cfg::client::disable_tsk_switch_shortcuts
, cfg::client::rdp_compression
, cfg::client::max_color_depth
, cfg::client::persistent_disk_bitmap_cache
, cfg::client::cache_waiting_list
, cfg::client::persist_bitmap_cache_on_disk
, cfg::client::bitmap_compression
, cfg::client::fast_path
, cfg::client::enable_suppress_output
, cfg::client::show_target_user_in_f12_message
, cfg::client::enable_new_pointer_update
, cfg::client::bogus_ios_glyph_support_level
, cfg::client::transform_glyph_to_bitmap
, cfg::client::bogus_number_of_fastpath_input_event
, cfg::client::recv_timeout
, cfg::client::enable_osd_4_eyes
{ static constexpr bool is_section = true; };

struct mod_rdp
: cfg::mod_rdp::open_session_timeout
, cfg::mod_rdp::load_balance_info
, cfg::mod_rdp::alternate_shell
, cfg::mod_rdp::shell_arguments
, cfg::mod_rdp::shell_working_directory
, cfg::mod_rdp::session_probe_clipboard_based_launcher_clipboard_initialization_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_start_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_long_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_short_delay
, cfg::mod_rdp::remoteapp_bypass_legal_notice_delay
, cfg::mod_rdp::remoteapp_bypass_legal_notice_timeout
, cfg::mod_rdp::rdp_compression
, cfg::mod_rdp::disconnect_on_logon_user_change
, cfg::mod_rdp::extra_orders
, cfg::mod_rdp::enable_nla
, cfg::mod_rdp::enable_kerberos
, cfg::mod_rdp::persistent_disk_bitmap_cache
, cfg::mod_rdp::cache_waiting_list
, cfg::mod_rdp::persist_bitmap_cache_on_disk
, cfg::mod_rdp::allow_channels
, cfg::mod_rdp::deny_channels
, cfg::mod_rdp::fast_path
, cfg::mod_rdp::server_redirection_support
, cfg::mod_rdp::redir_info
, cfg::mod_rdp::bogus_sc_net_size
, cfg::mod_rdp::proxy_managed_drives
, cfg::mod_rdp::ignore_auth_channel
, cfg::mod_rdp::auth_channel
, cfg::mod_rdp::checkout_channel
, cfg::mod_rdp::use_client_provided_alternate_shell
, cfg::mod_rdp::use_client_provided_remoteapp
, cfg::mod_rdp::use_native_remoteapp_capability
, cfg::mod_rdp::enable_session_probe
, cfg::mod_rdp::session_probe_use_clipboard_based_launcher
, cfg::mod_rdp::session_probe_enable_launch_mask
, cfg::mod_rdp::session_probe_on_launch_failure
, cfg::mod_rdp::session_probe_launch_timeout
, cfg::mod_rdp::session_probe_launch_fallback_timeout
, cfg::mod_rdp::session_probe_start_launch_timeout_timer_only_after_logon
, cfg::mod_rdp::session_probe_keepalive_timeout
, cfg::mod_rdp::session_probe_on_keepalive_timeout
, cfg::mod_rdp::session_probe_end_disconnected_session
, cfg::mod_rdp::session_probe_customize_executable_name
, cfg::mod_rdp::session_probe_enable_log
, cfg::mod_rdp::session_probe_enable_log_rotation
, cfg::mod_rdp::session_probe_disconnected_application_limit
, cfg::mod_rdp::session_probe_disconnected_session_limit
, cfg::mod_rdp::session_probe_idle_session_limit
, cfg::mod_rdp::session_probe_exe_or_file
, cfg::mod_rdp::session_probe_arguments
, cfg::mod_rdp::session_probe_allow_multiple_handshake
, cfg::mod_rdp::session_probe_enable_crash_dump
, cfg::mod_rdp::session_probe_handle_usage_limit
, cfg::mod_rdp::session_probe_memory_usage_limit
, cfg::mod_rdp::session_probe_ignore_ui_less_processes_during_end_of_session_check
, cfg::mod_rdp::session_probe_childless_window_as_unidentified_input_field
, cfg::mod_rdp::session_probe_public_session
, cfg::mod_rdp::server_cert_store
, cfg::mod_rdp::server_cert_check
, cfg::mod_rdp::server_access_allowed_message
, cfg::mod_rdp::server_cert_create_message
, cfg::mod_rdp::server_cert_success_message
, cfg::mod_rdp::server_cert_failure_message
, cfg::mod_rdp::server_cert_error_message
, cfg::mod_rdp::hide_client_name
, cfg::mod_rdp::clean_up_32_bpp_cursor
, cfg::mod_rdp::bogus_ios_rdpdr_virtual_channel
, cfg::mod_rdp::enable_rdpdr_data_analysis
, cfg::mod_rdp::log_only_relevant_clipboard_activities
, cfg::mod_rdp::experimental_fix_input_event_sync
, cfg::mod_rdp::experimental_fix_too_long_cookie
{ static constexpr bool is_section = true; };

struct metrics
: cfg::metrics::log_interval
, cfg::metrics::log_file_turnover_interval
, cfg::metrics::sign_key
, cfg::metrics::enable_rdp_metrics
, cfg::metrics::enable_vnc_metrics
, cfg::metrics::log_dir_path
{ static constexpr bool is_section = true; };

struct mod_vnc
: cfg::mod_vnc::clipboard_up
, cfg::mod_vnc::clipboard_down
, cfg::mod_vnc::encodings
, cfg::mod_vnc::server_clipboard_encoding_type
, cfg::mod_vnc::bogus_clipboard_infinite_loop
, cfg::mod_vnc::server_is_apple
, cfg::mod_vnc::server_unix_alt
{ static constexpr bool is_section = true; };

struct mod_replay
: cfg::mod_replay::on_end_of_data
, cfg::mod_replay::replay_on_loop
{ static constexpr bool is_section = true; };

struct ocr
: cfg::ocr::interval
, cfg::ocr::version
, cfg::ocr::locale
, cfg::ocr::on_title_bar_only
, cfg::ocr::max_unrecog_char_rate
{ static constexpr bool is_section = true; };

struct video
: cfg::video::break_interval
, cfg::video::capture_groupid
, cfg::video::png_interval
, cfg::video::frame_interval
, cfg::video::png_limit
, cfg::video::l_bitrate
, cfg::video::l_framerate
, cfg::video::l_height
, cfg::video::l_width
, cfg::video::l_qscale
, cfg::video::m_bitrate
, cfg::video::m_framerate
, cfg::video::m_height
, cfg::video::m_width
, cfg::video::m_qscale
, cfg::video::h_bitrate
, cfg::video::h_framerate
, cfg::video::h_height
, cfg::video::h_width
, cfg::video::h_qscale
, cfg::video::capture_flags
, cfg::video::replay_path
, cfg::video::hash_path
, cfg::video::record_tmp_path
, cfg::video::record_path
, cfg::video::disable_keyboard_log
, cfg::video::disable_clipboard_log
, cfg::video::disable_file_system_log
, cfg::video::rt_display
, cfg::video::wrm_color_depth_selection_strategy
, cfg::video::wrm_compression_algorithm
, cfg::video::bogus_vlc_frame_rate
, cfg::video::smart_video_cropping
, cfg::video::play_video_with_corrupted_bitmap
{ static constexpr bool is_section = true; };

struct crypto
: cfg::crypto::key0
, cfg::crypto::key1
{ static constexpr bool is_section = true; };

struct debug
: cfg::debug::fake_target_ip
, cfg::debug::config
, cfg::debug::x224
, cfg::debug::mcs
, cfg::debug::sec
, cfg::debug::rdp
, cfg::debug::primary_orders
, cfg::debug::secondary_orders
, cfg::debug::bitmap_update
, cfg::debug::bitmap
, cfg::debug::capture
, cfg::debug::auth
, cfg::debug::session
, cfg::debug::front
, cfg::debug::mod_rdp
, cfg::debug::mod_vnc
, cfg::debug::mod_internal
, cfg::debug::mod_xup
, cfg::debug::widget
, cfg::debug::input
, cfg::debug::password
, cfg::debug::compression
, cfg::debug::cache
, cfg::debug::performance
, cfg::debug::pass_dialog_box
, cfg::debug::ocr
, cfg::debug::ffmpeg
{ static constexpr bool is_section = true; };

struct remote_program
: cfg::remote_program::allow_resize_hosted_desktop
{ static constexpr bool is_section = true; };

struct translation
: cfg::translation::password_en
, cfg::translation::password_fr
, cfg::translation::language
{ static constexpr bool is_section = true; };

struct internal_mod
: cfg::internal_mod::theme
{ static constexpr bool is_section = true; };

struct context
: cfg::context::psid
, cfg::context::auth_error_message
, cfg::context::selector_device_filter
, cfg::context::selector_group_filter
, cfg::context::selector_proto_filter
, cfg::context::target_password
, cfg::context::target_host
, cfg::context::target_str
, cfg::context::target_service
, cfg::context::target_protocol
, cfg::context::password
, cfg::context::reporting
, cfg::context::auth_channel_answer
, cfg::context::auth_channel_target
, cfg::context::message
, cfg::context::rejected
, cfg::context::session_id
, cfg::context::end_time
, cfg::context::real_target_device
, cfg::context::ticket
, cfg::context::comment
, cfg::context::duration
, cfg::context::waitinforeturn
, cfg::context::module
, cfg::context::proxy_opt
, cfg::context::pattern_kill
, cfg::context::pattern_notify
, cfg::context::opt_message
, cfg::context::login_message
, cfg::context::session_probe_outbound_connection_monitoring_rules
, cfg::context::session_probe_process_monitoring_rules
, cfg::context::session_probe_extra_system_processes
, cfg::context::session_probe_windows_of_these_applications_as_unidentified_input_field
, cfg::context::disconnect_reason
, cfg::context::ip_target
, cfg::context::auth_command
, cfg::context::auth_notify
, cfg::context::auth_notify_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_original_exe_or_file
, cfg::context::auth_command_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_working_dir
, cfg::context::auth_command_rail_exec_arguments
, cfg::context::auth_command_rail_exec_account
, cfg::context::auth_command_rail_exec_password
, cfg::context::rail_disconnect_message_delay
, cfg::context::session_probe_launch_error_message
, cfg::context::close_box_extra_message
, cfg::context::pm_response
, cfg::context::pm_request
, cfg::context::opt_bitrate
, cfg::context::opt_framerate
, cfg::context::opt_qscale
, cfg::context::selector_current_page
, cfg::context::selector_lines_per_page
, cfg::context::selector_number_of_pages
, cfg::context::target_port
, cfg::context::end_date_cnx
, cfg::context::timezone
, cfg::context::duration_max
, cfg::context::formflag
, cfg::context::auth_notify_rail_exec_flags
, cfg::context::auth_command_rail_exec_exec_result
, cfg::context::auth_command_rail_exec_flags
, cfg::context::opt_bpp
, cfg::context::opt_height
, cfg::context::opt_width
, cfg::context::selector
, cfg::context::accept_message
, cfg::context::display_message
, cfg::context::authenticated
, cfg::context::keepalive
, cfg::context::mode_console
, cfg::context::authentication_challenge
, cfg::context::showform
, cfg::context::forcemodule
, cfg::context::disconnect_reason_ack
, cfg::context::recording_started
, cfg::context::rt_ready
, cfg::context::perform_automatic_reconnection
, cfg::context::use_session_probe_to_launch_remote_program
{ static constexpr bool is_section = true; };

} // namespace cfg_section

namespace configs {
struct VariablesConfiguration
: cfg_section::globals
, cfg_section::session_log
, cfg_section::client
, cfg_section::mod_rdp
, cfg_section::metrics
, cfg_section::mod_vnc
, cfg_section::mod_replay
, cfg_section::ocr
, cfg_section::video
, cfg_section::crypto
, cfg_section::debug
, cfg_section::remote_program
, cfg_section::translation
, cfg_section::internal_mod
, cfg_section::context
{};

using VariablesAclPack = Pack<
  cfg::globals::capture_chunk
, cfg::globals::auth_user
, cfg::globals::host
, cfg::globals::target
, cfg::globals::target_device
, cfg::globals::device_id
, cfg::globals::primary_user_id
, cfg::globals::target_user
, cfg::globals::target_application
, cfg::globals::target_application_account
, cfg::globals::target_application_password
, cfg::globals::inactivity_timeout
, cfg::globals::trace_type
, cfg::globals::is_rec
, cfg::globals::movie_path
, cfg::globals::unicode_keyboard_event_support
, cfg::globals::mod_recv_timeout
, cfg::session_log::log_path
, cfg::session_log::keyboard_input_masking_level
, cfg::client::keyboard_layout
, cfg::client::disable_tsk_switch_shortcuts
, cfg::mod_rdp::enable_nla
, cfg::mod_rdp::enable_kerberos
, cfg::mod_rdp::server_redirection_support
, cfg::mod_rdp::load_balance_info
, cfg::mod_rdp::bogus_sc_net_size
, cfg::mod_rdp::proxy_managed_drives
, cfg::mod_rdp::ignore_auth_channel
, cfg::mod_rdp::alternate_shell
, cfg::mod_rdp::shell_arguments
, cfg::mod_rdp::shell_working_directory
, cfg::mod_rdp::use_client_provided_alternate_shell
, cfg::mod_rdp::use_client_provided_remoteapp
, cfg::mod_rdp::use_native_remoteapp_capability
, cfg::mod_rdp::enable_session_probe
, cfg::mod_rdp::session_probe_use_clipboard_based_launcher
, cfg::mod_rdp::session_probe_enable_launch_mask
, cfg::mod_rdp::session_probe_on_launch_failure
, cfg::mod_rdp::session_probe_launch_timeout
, cfg::mod_rdp::session_probe_launch_fallback_timeout
, cfg::mod_rdp::session_probe_start_launch_timeout_timer_only_after_logon
, cfg::mod_rdp::session_probe_keepalive_timeout
, cfg::mod_rdp::session_probe_on_keepalive_timeout
, cfg::mod_rdp::session_probe_end_disconnected_session
, cfg::mod_rdp::session_probe_enable_log
, cfg::mod_rdp::session_probe_enable_log_rotation
, cfg::mod_rdp::session_probe_disconnected_application_limit
, cfg::mod_rdp::session_probe_disconnected_session_limit
, cfg::mod_rdp::session_probe_idle_session_limit
, cfg::mod_rdp::session_probe_clipboard_based_launcher_clipboard_initialization_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_start_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_long_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_short_delay
, cfg::mod_rdp::session_probe_enable_crash_dump
, cfg::mod_rdp::session_probe_handle_usage_limit
, cfg::mod_rdp::session_probe_memory_usage_limit
, cfg::mod_rdp::session_probe_ignore_ui_less_processes_during_end_of_session_check
, cfg::mod_rdp::session_probe_childless_window_as_unidentified_input_field
, cfg::mod_rdp::session_probe_public_session
, cfg::mod_rdp::server_cert_store
, cfg::mod_rdp::server_cert_check
, cfg::mod_rdp::server_access_allowed_message
, cfg::mod_rdp::server_cert_create_message
, cfg::mod_rdp::server_cert_success_message
, cfg::mod_rdp::server_cert_failure_message
, cfg::mod_rdp::enable_rdpdr_data_analysis
, cfg::mod_vnc::clipboard_up
, cfg::mod_vnc::clipboard_down
, cfg::mod_vnc::server_clipboard_encoding_type
, cfg::mod_vnc::bogus_clipboard_infinite_loop
, cfg::mod_vnc::server_is_apple
, cfg::mod_vnc::server_unix_alt
, cfg::mod_replay::replay_on_loop
, cfg::video::rt_display
, cfg::crypto::key0
, cfg::crypto::key1
, cfg::remote_program::allow_resize_hosted_desktop
, cfg::translation::language
, cfg::translation::password_en
, cfg::translation::password_fr
, cfg::context::psid
, cfg::context::opt_bitrate
, cfg::context::opt_framerate
, cfg::context::opt_qscale
, cfg::context::opt_bpp
, cfg::context::opt_height
, cfg::context::opt_width
, cfg::context::selector
, cfg::context::selector_current_page
, cfg::context::selector_device_filter
, cfg::context::selector_group_filter
, cfg::context::selector_proto_filter
, cfg::context::selector_lines_per_page
, cfg::context::selector_number_of_pages
, cfg::context::target_password
, cfg::context::target_host
, cfg::context::target_str
, cfg::context::target_service
, cfg::context::target_port
, cfg::context::target_protocol
, cfg::context::password
, cfg::context::reporting
, cfg::context::auth_channel_answer
, cfg::context::auth_channel_target
, cfg::context::message
, cfg::context::accept_message
, cfg::context::display_message
, cfg::context::rejected
, cfg::context::authenticated
, cfg::context::keepalive
, cfg::context::session_id
, cfg::context::end_date_cnx
, cfg::context::end_time
, cfg::context::mode_console
, cfg::context::timezone
, cfg::context::real_target_device
, cfg::context::authentication_challenge
, cfg::context::ticket
, cfg::context::comment
, cfg::context::duration
, cfg::context::duration_max
, cfg::context::waitinforeturn
, cfg::context::showform
, cfg::context::formflag
, cfg::context::module
, cfg::context::forcemodule
, cfg::context::proxy_opt
, cfg::context::pattern_kill
, cfg::context::pattern_notify
, cfg::context::opt_message
, cfg::context::login_message
, cfg::context::session_probe_outbound_connection_monitoring_rules
, cfg::context::session_probe_process_monitoring_rules
, cfg::context::session_probe_extra_system_processes
, cfg::context::session_probe_windows_of_these_applications_as_unidentified_input_field
, cfg::context::disconnect_reason
, cfg::context::disconnect_reason_ack
, cfg::context::recording_started
, cfg::context::rt_ready
, cfg::context::auth_command
, cfg::context::auth_notify
, cfg::context::auth_notify_rail_exec_flags
, cfg::context::auth_notify_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_exec_result
, cfg::context::auth_command_rail_exec_flags
, cfg::context::auth_command_rail_exec_original_exe_or_file
, cfg::context::auth_command_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_working_dir
, cfg::context::auth_command_rail_exec_arguments
, cfg::context::auth_command_rail_exec_account
, cfg::context::auth_command_rail_exec_password
, cfg::context::rail_disconnect_message_delay
, cfg::context::use_session_probe_to_launch_remote_program
, cfg::context::session_probe_launch_error_message
, cfg::context::pm_response
, cfg::context::pm_request
>;


struct BitFlags {
  uint64_t bits_[3];
  bool operator()(unsigned i) const noexcept { return bits_[i/64] & (uint64_t{1} << (i%64)); }
};

constexpr BitFlags is_loggable{{
  0b1111111111111111111111111111111111111111111111111111101111111111
, 0b1111111111111111111111111010111110111111111111111111001111111111
, 0b0000000000000000000000000000000000001111101111111111111111111111
}};
constexpr BitFlags is_unloggable_if_value_with_password{{
  0b0000000000000000000000000000000000000000000000000000000000000000
, 0b0000000000000000000000000100000000000000000000000000000000000000
, 0b0000000000000000000000000000000000000000000000000000000000000000
}};
} // namespace configs
